<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, viewport-fit=cover" />
  <title>Dictation Coach</title>

  <!-- Pinyin library (Mandarin Pinyin). Online CDN; for offline, download and use local file instead. -->
  <script src="https://unpkg.com/pinyin-pro@3.28.0/dist/index.js"></script>
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>

  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <div class="brandRow">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1 id="t_title">Dictation Coach</h1>
            <div class="subtitle" id="t_subtitle">Enter words → Speak → Write → Show order (with pinyin)</div>
          </div>
        </div>
      </div>

      <div class="rightTop">
        <div class="seg" role="group" aria-label="Language">
          <button class="langBtn" data-lang="zh-Hant">繁</button>
          <button class="langBtn" data-lang="zh-Hans">簡</button>
          <button class="langBtn" data-lang="en">Eng</button>
        </div>

        <div class="chips">
          <div class="chip"><span id="versionChip">Beta v0.1.0</span></div>
          <div class="chip"><span id="pinyinDot" class="dot"></span><span id="pinyinChip">Pinyin: LOADING</span></div>
          <div class="chip"><span id="voiceDot" class="dot"></span><span id="voiceChip">Voice: LOADING</span></div>
        </div>
      </div>
    </div>

    <div class="grid">
      <!-- Left -->
      <div class="card">
        <div class="cardHeader">
          <div class="cardTitle" id="t_wordsTitle">Word list</div>
          <div class="hint" id="t_wordsHint">space / newline separated</div>
        </div>

        <textarea id="words" placeholder="Example:
顯著
變焦鏡頭
發售"></textarea>

        <div class="formRow">
          <div class="field">
            <label for="repeat" id="t_repeatLabel">Repeat</label>
            <input id="repeat" type="number" min="1" value="2" />
          </div>
          <div class="field">
            <label for="rate" id="t_rateLabel">Speech rate</label>
            <input id="rate" type="number" min="0.5" max="2" step="0.1" value="1" />
          </div>
          <div class="field">
            <label for="voice" id="t_voiceLabel">Voice</label>
            <select id="voice"></select>
          </div>
          <div class="field">
            <label for="parseMode" id="t_modeLabel">Parse mode</label>
            <select id="parseMode">
              <option value="line" id="t_modeLine">Line mode</option>
              <option value="word" id="t_modeWord">Word mode</option>
            </select>
          </div>
        </div>

        <!-- Shuffle toggle -->
        <div class="toggleRow">
          <div class="switch">
            <div class="switchText">
              <b id="t_shuffleTitle">Shuffle words</b>
              <span id="t_shuffleDesc">Random order (OFF = follow input order)</span>
            </div>
          </div>
          <div id="shuffleSwitch" class="iosSwitch on" role="switch" aria-checked="true" tabindex="0" title="Shuffle toggle">
            <div class="knob"></div>
          </div>
        </div>

        <!-- Now speaking -->
        <div class="nowCard">
          <div class="nowLabel" id="t_currentLabel">Now speaking</div>
          <div class="nowWord" id="currentWord">—</div>
          <div class="nowPinyin" id="currentPinyin"></div>

          <div class="progress" aria-label="progress">
            <div class="bar" id="bar"></div>
          </div>

          <div class="statusLine">
            <div><span id="t_statusLabel">Status</span>：<span class="statusStrong" id="status"></span></div>
            <div><span id="counter">0 / 0</span></div>
          </div>
        </div>

        <div class="miniActions">
          <button class="miniBtn" id="print">Print</button>
          <button class="miniBtn" id="testPinyin">Test pinyin</button>
          <button class="miniBtn" id="clearText">Clear text</button>
          <button class="miniBtn" id="dedupe">Remove duplicates</button>
          <button class="miniBtn" id="importImage">Import image</button>
          <button class="miniBtn" id="importPdf">Import PDF</button>
          <button class="miniBtn" id="markWrong">Mark wrong</button>
          <button class="miniBtn" id="startRetry">Start retry</button>
          <input id="imageInput" type="file" accept="image/*" hidden />
          <input id="pdfInput" type="file" accept="application/pdf,.pdf" hidden />
        </div>
      </div>

      <!-- Right -->
      <div class="card">
        <div class="cardHeader">
          <div class="cardTitle" id="t_orderTitle">Speaking order</div>
          <div class="hint" id="t_orderHint">Shown after finish / stop</div>
        </div>

        <ol class="list" id="order"></ol>

        <div class="footerNote" id="t_footerNote">
          Tip: If Pinyin shows OFF, the CDN may be blocked/offline. Download pinyin-pro.min.js and reference it locally for offline use.
        </div>
      </div>
    </div>
  </div>

  <!-- Sticky controls -->
  <div class="controls">
    <div class="controlsInner">
      <button class="btn primary" id="start"><span id="t_start">Start</span></button>
      <button class="btn ghost" id="pause"><span id="t_pause">Pause</span></button>
      <button class="btn ghost" id="resume"><span id="t_resume">Resume</span></button>
      <button class="btn danger" id="stop"><span id="t_stop">Stop</span></button>
    </div>
  </div>

  <!-- Print-only area -->
  <div id="printArea"></div>

<script>
(() => {
  // ---------- i18n ----------
  const I18N = {
    "zh-Hant": {
      title: "中文默書",
      subtitle: "輸入詞語 → 朗讀 → 小朋友寫字 → 顯示朗讀順序（含拼音）",
      wordsTitle: "詞語清單",
      wordsHint: "空格 / 換行分隔",
      repeatLabel: "重複次數",
      rateLabel: "語速",
      voiceLabel: "語音 Voice",
      modeLabel: "練習模式",
      modeLine: "逐行模式",
      modeWord: "逐詞模式",
      shuffleTitle: "隨機排序",
      shuffleDesc: "開啟 = 隨機；關閉 = 跟輸入次序",
      currentLabel: "目前朗讀",
      statusLabel: "狀態",
      orderTitle: "朗讀順序",
      orderHint: "完成後 / 停止後會顯示",
      footerNote: "提示：如果 Pinyin 顯示 OFF，可能離線/網絡被擋。可下載 pinyin-pro.min.js 放同一資料夾離線使用。",
      versionLabel: (v) => `Beta ${v}`,
      start: "開始",
      pause: "暫停",
      resume: "繼續",
      stop: "停止",
      print: "列印順序",
      testPinyin: "測試拼音",
      clearText: "清空文字",
      dedupe: "移除重覆",
      importImage: "圖片匯入",
      importPdf: "PDF 匯入",
      markWrong: "標記錯題",
      startRetry: "重溫錯題",
      placeholder: "例如：\n顯著\n變焦鏡頭\n發售",
      // Status states
      ready: "準備就緒",
      speaking: "朗讀中",
      paused: "已暫停",
      resumed: "繼續中",
      stopped: "已停止",
      done: "完成",
      // Messages
      needWords: "請先輸入詞語",
      noSpeechApi: "此瀏覽器不支援語音。請用 Chrome / Edge。",
      pinyinOff: "拼音 OFF（可能離線/被擋）。請確保可連網或用本機 pinyin-pro.min.js",
      pinyinTest: (w, py) => `拼音測試：${w} → ${py}`,
      ocrReading: "正在辨識圖片文字…",
      ocrProgress: (pct) => `OCR 辨識中 ${pct}%`,
      ocrEmpty: "未能從圖片讀到文字",
      ocrDone: "已從圖片匯入文字（保留原本排版）",
      cleared: "已清空文字",
      deduped: (n) => `已移除 ${n} 個重覆項目`,
      noDuplicates: "沒有重覆項目",
      ocrNoApi: "OCR 載入失敗，請檢查網絡",
      ocrFailed: "圖片辨識失敗，請換另一張較清晰圖片",
      pdfReading: "正在讀取 PDF…",
      pdfDone: "已從 PDF 匯入文字",
      pdfNoApi: "PDF 載入失敗，請檢查網絡",
      pdfFailed: "PDF 匯入失敗，請換檔案再試",
      pdfOcrFallback: "PDF 文字層不足，改用 OCR…",
      markedWrong: (w, n) => `已標記錯題：${w}（共 ${n}）`,
      markWrongIdle: "請在朗讀中先標記錯題",
      retryReady: (n) => `已建立錯題重溫清單（${n}）`,
      retryNoItems: "沒有已標記錯題",
      retryStarted: "開始重溫錯題"
    },
    "zh-Hans": {
      title: "中文听写",
      subtitle: "输入词语 → 朗读 → 孩子书写 → 显示朗读顺序（含拼音）",
      wordsTitle: "词语列表",
      wordsHint: "空格 / 换行分隔",
      repeatLabel: "重复次数",
      rateLabel: "语速",
      voiceLabel: "语音 Voice",
      modeLabel: "练习模式",
      modeLine: "逐行模式",
      modeWord: "逐词模式",
      shuffleTitle: "随机排序",
      shuffleDesc: "开启 = 随机；关闭 = 按输入顺序",
      currentLabel: "当前朗读",
      statusLabel: "状态",
      orderTitle: "朗读顺序",
      orderHint: "完成后 / 停止后会显示",
      footerNote: "提示：如果拼音显示 OFF，可能离线/被拦。可下载 pinyin-pro.min.js 放同一文件夹离线使用。",
      versionLabel: (v) => `Beta ${v}`,
      start: "开始",
      pause: "暂停",
      resume: "继续",
      stop: "停止",
      print: "打印顺序",
      testPinyin: "测试拼音",
      clearText: "清空文字",
      dedupe: "移除重复",
      importImage: "图片导入",
      importPdf: "PDF 导入",
      markWrong: "标记错题",
      startRetry: "重练错题",
      placeholder: "例如：\n显著\n变焦镜头\n发售",
      ready: "准备就绪",
      speaking: "朗读中",
      paused: "已暂停",
      resumed: "继续中",
      stopped: "已停止",
      done: "完成",
      needWords: "请先输入词语",
      noSpeechApi: "此浏览器不支持语音。请用 Chrome / Edge。",
      pinyinOff: "拼音 OFF（可能离线/被拦）。请确保可联网或用本机 pinyin-pro.min.js",
      pinyinTest: (w, py) => `拼音测试：${w} → ${py}`,
      ocrReading: "正在识别图片文字…",
      ocrProgress: (pct) => `OCR 识别中 ${pct}%`,
      ocrEmpty: "未能从图片读取到文字",
      ocrDone: "已从图片导入文字（保留原始排版）",
      cleared: "已清空文字",
      deduped: (n) => `已移除 ${n} 个重复项目`,
      noDuplicates: "没有重复项目",
      ocrNoApi: "OCR 加载失败，请检查网络",
      ocrFailed: "图片识别失败，请换更清晰的图片",
      pdfReading: "正在读取 PDF…",
      pdfDone: "已从 PDF 导入文字",
      pdfNoApi: "PDF 加载失败，请检查网络",
      pdfFailed: "PDF 导入失败，请更换文件再试",
      pdfOcrFallback: "PDF 文本层不足，改用 OCR…",
      markedWrong: (w, n) => `已标记错题：${w}（共 ${n}）`,
      markWrongIdle: "请在朗读中先标记错题",
      retryReady: (n) => `已生成错题重练清单（${n}）`,
      retryNoItems: "没有已标记错题",
      retryStarted: "开始重练错题"
    },
    "en": {
      title: "Dictation Coach",
      subtitle: "Enter words → Speak → Kids write → Show speaking order (with pinyin)",
      wordsTitle: "Word list",
      wordsHint: "Separated by spaces / new lines",
      repeatLabel: "Repeat",
      rateLabel: "Speech rate",
      voiceLabel: "Voice",
      modeLabel: "Practice mode",
      modeLine: "Line mode",
      modeWord: "Word mode",
      shuffleTitle: "Shuffle words",
      shuffleDesc: "ON = random; OFF = input order",
      currentLabel: "Now speaking",
      statusLabel: "Status",
      orderTitle: "Speaking order",
      orderHint: "Shown after finish / stop",
      footerNote: "Tip: If Pinyin shows OFF, the CDN may be blocked/offline. Download pinyin-pro.min.js and reference it locally for offline use.",
      versionLabel: (v) => `Beta ${v}`,
      start: "Start",
      pause: "Pause",
      resume: "Resume",
      stop: "Stop",
      print: "Print order",
      testPinyin: "Test pinyin",
      clearText: "Clear text",
      dedupe: "Remove duplicates",
      importImage: "Import image",
      importPdf: "Import PDF",
      markWrong: "Mark wrong",
      startRetry: "Start retry",
      placeholder: "Example:\n顯著\n變焦鏡頭\n發售",
      ready: "Ready",
      speaking: "Speaking",
      paused: "Paused",
      resumed: "Resumed",
      stopped: "Stopped",
      done: "Done",
      needWords: "Please enter words first",
      noSpeechApi: "Speech not supported. Use Chrome / Edge.",
      pinyinOff: "Pinyin OFF (offline / blocked). Use online or local pinyin-pro.min.js",
      pinyinTest: (w, py) => `Pinyin test: ${w} → ${py}`,
      ocrReading: "Reading text from image...",
      ocrProgress: (pct) => `OCR in progress ${pct}%`,
      ocrEmpty: "No text detected from image",
      ocrDone: "Imported text from image (original layout preserved)",
      cleared: "Text cleared",
      deduped: (n) => `Removed ${n} duplicate items`,
      noDuplicates: "No duplicate items",
      ocrNoApi: "OCR failed to load. Check your network.",
      ocrFailed: "Image OCR failed. Try a clearer image.",
      pdfReading: "Reading PDF...",
      pdfDone: "Imported text from PDF",
      pdfNoApi: "PDF failed to load. Check your network.",
      pdfFailed: "PDF import failed. Try another file.",
      pdfOcrFallback: "PDF has little text layer, using OCR...",
      markedWrong: (w, n) => `Marked wrong: ${w} (${n})`,
      markWrongIdle: "Start speaking first, then mark wrong items",
      retryReady: (n) => `Retry list generated (${n})`,
      retryNoItems: "No marked wrong items",
      retryStarted: "Retry round started"
    }
  };

  let currentLang = localStorage.getItem("dict_lang") || "zh-Hant";
  const APP_VERSION = "v0.1.0";
  function t(){ return I18N[currentLang] || I18N["zh-Hant"]; }

  // ---------- elements ----------
  const elWords = document.getElementById('words');
  const elRepeat = document.getElementById('repeat');
  const elRate = document.getElementById('rate');
  const elVoice = document.getElementById('voice');
  const elParseMode = document.getElementById('parseMode');
  const elOrder = document.getElementById('order');
  const elCounter = document.getElementById('counter');
  const elBar = document.getElementById('bar');
  const elCurrentWord = document.getElementById('currentWord');
  const elCurrentPinyin = document.getElementById('currentPinyin');

  const pinyinDot = document.getElementById('pinyinDot');
  const pinyinChip = document.getElementById('pinyinChip');
  const voiceDot = document.getElementById('voiceDot');
  const voiceChip = document.getElementById('voiceChip');
  const versionChip = document.getElementById('versionChip');

  const btnStart = document.getElementById('start');
  const btnPause = document.getElementById('pause');
  const btnResume = document.getElementById('resume');
  const btnStop = document.getElementById('stop');
  const btnPrint = document.getElementById('print');
  const btnTestPinyin = document.getElementById('testPinyin');
  const btnClearText = document.getElementById('clearText');
  const btnDedupe = document.getElementById('dedupe');
  const btnImportImage = document.getElementById('importImage');
  const btnImportPdf = document.getElementById('importPdf');
  const btnMarkWrong = document.getElementById('markWrong');
  const btnStartRetry = document.getElementById('startRetry');
  const imageInput = document.getElementById('imageInput');
  const pdfInput = document.getElementById('pdfInput');

  const shuffleSwitch = document.getElementById('shuffleSwitch');

  // ---------- state ----------
  let running = false;
  let cancelled = false;
  let parseMode = localStorage.getItem("dict_parse_mode") || "line";

  let shuffleEnabled = (localStorage.getItem("dict_shuffle") ?? "1") === "1";

  let plannedOrder = [];   // order for this session (shuffled or input order)
  let spokenOrder = [];    // actual spoken sequence
  let total = 0;
  let currentItem = "";
  let retryItems = [];
  let retrySet = new Set();
  let inRetryRound = false;

  let statusKey = "ready";     // ready | speaking | paused | resumed | stopped | done
  let statusOverride = "";     // custom message string

  // ---------- helpers ----------
  function setText(id, value){
    const el = document.getElementById(id);
    if (el) el.textContent = value;
  }

  function applyLang(){
    const dict = t();
    document.documentElement.lang = currentLang;

    setText("t_title", dict.title);
    setText("t_subtitle", dict.subtitle);

    setText("t_wordsTitle", dict.wordsTitle);
    setText("t_wordsHint", dict.wordsHint);

    setText("t_repeatLabel", dict.repeatLabel);
    setText("t_rateLabel", dict.rateLabel);
    setText("t_voiceLabel", dict.voiceLabel);
    setText("t_modeLabel", dict.modeLabel);
    setText("t_modeLine", dict.modeLine);
    setText("t_modeWord", dict.modeWord);

    setText("t_shuffleTitle", dict.shuffleTitle);
    setText("t_shuffleDesc", dict.shuffleDesc);

    setText("t_currentLabel", dict.currentLabel);

    setText("t_statusLabel", dict.statusLabel);

    setText("t_orderTitle", dict.orderTitle);
    setText("t_orderHint", dict.orderHint);
    setText("t_footerNote", dict.footerNote);
    versionChip.textContent = dict.versionLabel(APP_VERSION);

    setText("t_start", dict.start);
    setText("t_pause", dict.pause);
    setText("t_resume", dict.resume);
    setText("t_stop", dict.stop);

    btnPrint.textContent = dict.print;
    btnTestPinyin.textContent = dict.testPinyin;
    btnClearText.textContent = dict.clearText;
    btnDedupe.textContent = dict.dedupe;
    btnImportImage.textContent = dict.importImage;
    btnImportPdf.textContent = dict.importPdf;
    btnMarkWrong.textContent = dict.markWrong;
    updateRetryButtonLabel();

    elWords.placeholder = dict.placeholder;

    // lang segmented active
    document.querySelectorAll(".langBtn").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.lang === currentLang);
    });

    // status re-render in new language
    renderStatus();
    renderOrder(); // keep list label/pinyin consistent
  }

  function renderStatus(){
    const st = document.getElementById("status");
    if (!st) return;
    const dict = t();
    st.textContent = statusOverride || dict[statusKey] || dict.ready || "Ready";
  }

  function setStatusKey(key){
    statusOverride = "";
    statusKey = key;
    renderStatus();
  }

  function setStatusText(text){
    statusOverride = text || "";
    renderStatus();
  }

  function parseWords(text){
    return text.split(/\s+/).map(s => s.trim()).filter(Boolean);
  }

  function parseLines(text){
    return String(text || "").replace(/\r/g, "\n").split("\n").map(s => s.trim()).filter(Boolean);
  }

  function parseUnits(text){
    return parseMode === "line" ? parseLines(text) : parseWords(text);
  }

  function rebuildPreview(){
    if (!running){
      const units = parseUnits(elWords.value);
      plannedOrder = units.length ? buildPlan(units) : [];
      spokenOrder = [];
      renderOrder();
    }
  }

  function updateRetryButtonLabel(){
    const base = t().startRetry || "Start retry";
    btnStartRetry.textContent = retryItems.length ? `${base} (${retryItems.length})` : base;
  }

  function ocrLanguage(){
    if (currentLang === "zh-Hant") return "chi_tra";
    if (currentLang === "zh-Hans") return "chi_sim";
    return "eng";
  }

  function shuffle(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function setCounter(i, n){
    elCounter.textContent = `${i} / ${n}`;
  }
  function setProgress(i, n){
    const pct = n ? Math.round((i / n) * 100) : 0;
    elBar.style.width = `${pct}%`;
  }

  function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

  // Pinyin lib (correct global)
  function getPinyinLib(){
    if (window.pinyinPro && typeof window.pinyinPro.pinyin === "function") return window.pinyinPro;
    if (window.pinyinPro?.default && typeof window.pinyinPro.default.pinyin === "function") return window.pinyinPro.default;
    return null;
  }

  function updatePinyinChip(){
    const ok = !!getPinyinLib();
    pinyinChip.textContent = `Pinyin: ${ok ? "ON" : "OFF"}`;
    pinyinDot.className = "dot " + (ok ? "ok" : "");
  }

  function pinyinOf(word){
    const lib = getPinyinLib();
    const hasChinese = /[\u4e00-\u9fff]/.test(word);
    if (!hasChinese || !lib) return "";
    const arr = lib.pinyin(word, { toneType: "symbol", type: "array" });
    return Array.isArray(arr) ? arr.join(" ") : String(arr || "");
  }

  // Voices
  function getVoices(){
    if (!('speechSynthesis' in window)) return [];
    return window.speechSynthesis.getVoices() || [];
  }

  function loadVoiceOptions(){
    const voices = getVoices();
    elVoice.innerHTML = "";

    if (!voices.length){
      const opt = document.createElement('option');
      opt.value = "-1";
      opt.textContent = "（No voices detected / Use default）";
      elVoice.appendChild(opt);
      voiceChip.textContent = "Voice: EMPTY";
      voiceDot.className = "dot";
      return;
    }

    const list = voices.map((v, idx) => ({ v, idx }))
      .sort((a, b) => {
        const az = /^zh/i.test(a.v.lang) ? 0 : 1;
        const bz = /^zh/i.test(b.v.lang) ? 0 : 1;
        return az - bz;
      });

    for (const item of list){
      const opt = document.createElement('option');
      opt.value = String(item.idx);
      opt.textContent = `${item.v.name} — ${item.v.lang}${item.v.default ? " (default)" : ""}`;
      elVoice.appendChild(opt);
    }

    // auto pick first zh voice if exists
    const firstZh = list.find(x => /^zh/i.test(x.v.lang));
    elVoice.value = firstZh ? String(firstZh.idx) : String(list[0].idx);

    voiceChip.textContent = "Voice: OK";
    voiceDot.className = "dot ok";
  }

  function selectedVoice(){
    const voices = getVoices();
    const idx = Number(elVoice.value);
    if (!Number.isFinite(idx) || idx < 0) return null;
    return voices[idx] || null;
  }

  function speakOnce(text, { voice, rate } = {}){
    return new Promise((resolve, reject) => {
      const u = new SpeechSynthesisUtterance(text);
      if (voice) u.voice = voice;
      u.lang = voice?.lang || "zh-HK";
      u.rate = rate;

      u.onend = () => resolve();
      u.onerror = (e) => reject(e);

      window.speechSynthesis.speak(u);
    });
  }

  function renderOrder(){
    const list = (spokenOrder.length ? spokenOrder : plannedOrder);
    elOrder.innerHTML = "";
    for (const w of list){
      const li = document.createElement("li");
      li.textContent = w;

      const py = pinyinOf(w);
      if (py){
        const sm = document.createElement("small");
        sm.textContent = py;
        li.appendChild(sm);
      }
      elOrder.appendChild(li);
    }
  }

  // Print: always use printArea only
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, (m) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;"
    }[m]));
  }
  function nextFrame(){ return new Promise(res => requestAnimationFrame(() => res())); }

  async function doPrint(){
    const units = parseUnits(elWords.value);
    if (!units.length){
      setStatusText(t().needWords);
      return;
    }

    // Use spoken if available, else planned, else build new plan with current shuffle mode
    const list = spokenOrder.length ? spokenOrder
               : plannedOrder.length ? plannedOrder
               : (shuffleEnabled ? shuffle(units) : units.slice());

    const now = new Date();
    const dateStr = now.toLocaleString();

    const itemsHtml = list.map(w => {
      const py = pinyinOf(w);
      return `<li>${escapeHtml(w)}${py ? `<small>${escapeHtml(py)}</small>` : ""}</li>`;
    }).join("");

    const printArea = document.getElementById("printArea");
    printArea.innerHTML = `
      <h1>${escapeHtml(t().title)}</h1>
      <div class="meta">Date: ${escapeHtml(dateStr)} ｜ Total: ${list.length}</div>
      <ol>${itemsHtml}</ol>
    `;

    await nextFrame(); await nextFrame();
    window.print();
  }

  // Build a plan for the session using shuffle toggle
  function buildPlan(words){
    return shuffleEnabled ? shuffle(words) : words.slice();
  }

  function updateShuffleUI(){
    shuffleSwitch.classList.toggle("on", shuffleEnabled);
    shuffleSwitch.setAttribute("aria-checked", shuffleEnabled ? "true" : "false");
  }

  async function run(){
    cancelled = false;
    running = true;
    spokenOrder = [];
    currentItem = "";
    elOrder.innerHTML = "";

    const units = parseUnits(elWords.value);
    const repeat = Math.max(1, parseInt(elRepeat.value || "1", 10));
    const rate = Math.min(2, Math.max(0.5, parseFloat(elRate.value || "1")));
    const voice = selectedVoice();

    if (!units.length){
      setStatusText(t().needWords);
      running = false;
      return;
    }

    // plannedOrder is created on Start; if not, create here
    if (!plannedOrder.length) plannedOrder = buildPlan(units);

    total = plannedOrder.length;
    setCounter(0, total);
    setProgress(0, total);

    setStatusKey("speaking");

    try{
      for (let i = 0; i < plannedOrder.length; i++){
        if (cancelled) break;

        const w = plannedOrder[i];
        currentItem = w;
        spokenOrder.push(w);

        elCurrentWord.textContent = w;
        elCurrentPinyin.textContent = pinyinOf(w);

        setCounter(i + 1, total);
        setProgress(i + 1, total);

        for (let r = 0; r < repeat; r++){
          if (cancelled) break;
          await speakOnce(w, { voice, rate });
          await sleep(420);
        }
        await sleep(650);
      }
    } catch (err){
      console.error(err);
      setStatusText(t().noSpeechApi);
    } finally {
      running = false;
      currentItem = "";
      window.speechSynthesis.cancel();
    }

    renderOrder();
    if (cancelled) setStatusKey("stopped");
    else {
      setStatusKey("done");
      if (!inRetryRound && retryItems.length){
        setStatusText(t().retryReady(retryItems.length));
      }
    }
  }

  // ---------- events ----------
  document.querySelectorAll(".langBtn").forEach(btn => {
    btn.addEventListener("click", () => {
      currentLang = btn.dataset.lang;
      localStorage.setItem("dict_lang", currentLang);
      applyLang();
    });
  });

  function toggleShuffle(){
    shuffleEnabled = !shuffleEnabled;
    localStorage.setItem("dict_shuffle", shuffleEnabled ? "1" : "0");
    updateShuffleUI();

    // If not running, rebuild plan preview (so the order list matches the mode)
    if (!running){
      rebuildPreview();
    }
  }

  shuffleSwitch.addEventListener("click", toggleShuffle);
  shuffleSwitch.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " "){
      e.preventDefault();
      toggleShuffle();
    }
  });

  btnStart.addEventListener('click', () => {
    if (!('speechSynthesis' in window)){
      setStatusText(t().noSpeechApi);
      return;
    }

    const units = parseUnits(elWords.value);
    if (!units.length){
      setStatusText(t().needWords);
      return;
    }

    // Start a fresh session plan every time you press Start
    retryItems = [];
    retrySet = new Set();
    updateRetryButtonLabel();
    inRetryRound = false;
    plannedOrder = buildPlan(units);
    spokenOrder = [];
    renderOrder();

    window.speechSynthesis.cancel();
    setStatusKey("ready");
    run();
  });

  btnPause.addEventListener('click', () => {
    if (!('speechSynthesis' in window)) return;
    window.speechSynthesis.pause();
    setStatusKey("paused");
  });

  btnResume.addEventListener('click', () => {
    if (!('speechSynthesis' in window)) return;
    window.speechSynthesis.resume();
    setStatusKey("resumed");
  });

  btnStop.addEventListener('click', () => {
    cancelled = true;
    window.speechSynthesis.cancel();
    renderOrder();
    setStatusKey("stopped");
  });

  btnPrint.addEventListener('click', () => {
    doPrint();
  });

  btnTestPinyin.addEventListener('click', () => {
    updatePinyinChip();
    const lib = getPinyinLib();
    const sample = parseUnits(elWords.value).find(w => /[\u4e00-\u9fff]/.test(w)) || "顯著";
    if (!lib){
      setStatusText(t().pinyinOff);
      return;
    }
    setStatusText(t().pinyinTest(sample, pinyinOf(sample)));
  });

  btnClearText.addEventListener('click', () => {
    elWords.value = "";
    plannedOrder = [];
    spokenOrder = [];
    retryItems = [];
    retrySet = new Set();
    updateRetryButtonLabel();
    inRetryRound = false;
    elOrder.innerHTML = "";
    elCurrentWord.textContent = "—";
    elCurrentPinyin.textContent = "";
    setCounter(0, 0);
    setProgress(0, 0);
    setStatusText(t().cleared);
  });

  btnDedupe.addEventListener('click', () => {
    const lines = String(elWords.value || "").replace(/\r/g, "\n").split("\n");
    const seen = new Set();
    let removed = 0;
    const kept = [];
    for (const line of lines){
      const key = line.trim();
      if (!key){
        kept.push(line);
        continue;
      }
      if (seen.has(key)){
        removed++;
        continue;
      }
      seen.add(key);
      kept.push(line);
    }
    elWords.value = kept.join("\n").replace(/\n{3,}/g, "\n\n");
    rebuildPreview();
    setStatusText(removed ? t().deduped(removed) : t().noDuplicates);
  });

  btnImportImage.addEventListener('click', () => {
    imageInput.value = "";
    imageInput.click();
  });

  imageInput.addEventListener('change', async () => {
    const file = imageInput.files?.[0];
    if (!file) return;
    if (!window.Tesseract || typeof window.Tesseract.recognize !== "function"){
      setStatusText(t().ocrNoApi);
      return;
    }

    try{
      setStatusText(t().ocrReading);
      const { data } = await window.Tesseract.recognize(file, ocrLanguage(), {
        logger: (m) => {
          if (m?.status === "recognizing text" && Number.isFinite(m.progress)) {
            const pct = Math.max(0, Math.min(100, Math.round(m.progress * 100)));
            setStatusText(t().ocrProgress(pct));
          }
        }
      });

      const importedText = String(data?.text || "").replace(/\r/g, "\n").trim();
      if (!importedText){
        setStatusText(t().ocrEmpty);
        return;
      }

      const existingText = elWords.value || "";
      elWords.value = existingText.trim()
        ? `${existingText.replace(/\s*$/, "")}\n${importedText}`
        : importedText;

      rebuildPreview();
      setStatusText(t().ocrDone);
    } catch (err){
      console.error(err);
      setStatusText(t().ocrFailed);
    }
  });

  async function readPdfTextLayer(file){
    const pdfjsLib = window.pdfjsLib;
    if (!pdfjsLib || typeof pdfjsLib.getDocument !== "function"){
      throw new Error("PDF API unavailable");
    }
    if (!pdfjsLib.GlobalWorkerOptions.workerSrc){
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    }

    const ab = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
    const pageTexts = [];
    for (let i = 1; i <= pdf.numPages; i++){
      const page = await pdf.getPage(i);
      const tc = await page.getTextContent();
      const parts = tc.items.map(item => String(item.str || "").trim()).filter(Boolean);
      pageTexts.push(parts.join(" "));
    }
    return pageTexts.join("\n").trim();
  }

  async function readPdfByOcr(file){
    const pdfjsLib = window.pdfjsLib;
    if (!pdfjsLib || typeof pdfjsLib.getDocument !== "function"){
      throw new Error("PDF API unavailable");
    }
    if (!window.Tesseract || typeof window.Tesseract.recognize !== "function"){
      throw new Error("OCR API unavailable");
    }
    if (!pdfjsLib.GlobalWorkerOptions.workerSrc){
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    }

    const ab = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
    const ocrPages = [];
    for (let i = 1; i <= pdf.numPages; i++){
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: 2.0 });
      const canvas = document.createElement("canvas");
      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);
      const ctx = canvas.getContext("2d");
      await page.render({ canvasContext: ctx, viewport }).promise;
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
      if (!blob) continue;

      const { data } = await window.Tesseract.recognize(blob, ocrLanguage(), {
        logger: (m) => {
          if (m?.status === "recognizing text" && Number.isFinite(m.progress)){
            const pct = Math.max(0, Math.min(100, Math.round(m.progress * 100)));
            setStatusText(`${t().pdfOcrFallback} ${i}/${pdf.numPages} ${pct}%`);
          }
        }
      });
      const text = String(data?.text || "").replace(/\r/g, "\n").trim();
      if (text) ocrPages.push(text);
    }
    return ocrPages.join("\n").trim();
  }

  btnImportPdf.addEventListener('click', () => {
    pdfInput.value = "";
    pdfInput.click();
  });

  pdfInput.addEventListener('change', async () => {
    const file = pdfInput.files?.[0];
    if (!file) return;
    try{
      setStatusText(t().pdfReading);
      let importedText = await readPdfTextLayer(file);
      const compactLen = importedText.replace(/\s+/g, "").length;
      if (compactLen < 20){
        setStatusText(t().pdfOcrFallback);
        importedText = await readPdfByOcr(file);
      }
      if (!importedText){
        setStatusText(t().ocrEmpty);
        return;
      }
      const existingText = elWords.value || "";
      elWords.value = existingText.trim()
        ? `${existingText.replace(/\s*$/, "")}\n${importedText}`
        : importedText;
      rebuildPreview();
      setStatusText(t().pdfDone);
    } catch (err){
      console.error(err);
      const msg = String(err?.message || "");
      setStatusText(msg.includes("PDF API") ? t().pdfNoApi : t().pdfFailed);
    }
  });

  btnMarkWrong.addEventListener('click', () => {
    if (!running || !currentItem){
      setStatusText(t().markWrongIdle);
      return;
    }
    if (!retrySet.has(currentItem)){
      retrySet.add(currentItem);
      retryItems.push(currentItem);
      updateRetryButtonLabel();
    }
    setStatusText(t().markedWrong(currentItem, retryItems.length));
  });

  btnStartRetry.addEventListener('click', () => {
    if (running) return;
    if (!retryItems.length){
      setStatusText(t().retryNoItems);
      return;
    }
    inRetryRound = true;
    plannedOrder = retryItems.slice();
    spokenOrder = [];
    renderOrder();
    window.speechSynthesis.cancel();
    setStatusText(t().retryStarted);
    run().finally(() => {
      inRetryRound = false;
    });
  });

  elParseMode.addEventListener('change', () => {
    parseMode = elParseMode.value === "word" ? "word" : "line";
    localStorage.setItem("dict_parse_mode", parseMode);
    rebuildPreview();
  });

  // ---------- init ----------
  if (parseMode !== "line" && parseMode !== "word") parseMode = "line";
  updateShuffleUI();
  updatePinyinChip();
  elParseMode.value = parseMode;
  window.addEventListener("load", updatePinyinChip);

  // voices load async in many browsers
  if ('speechSynthesis' in window){
    loadVoiceOptions();
    window.speechSynthesis.onvoiceschanged = () => loadVoiceOptions();
  } else {
    voiceChip.textContent = "Voice: NO API";
    voiceDot.className = "dot";
  }

  // set initial status & language
  setStatusKey("ready");
  applyLang();
})();
</script>
</body>
</html>
